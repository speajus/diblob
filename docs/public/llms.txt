# Diblob - Dependency Injection Framework

> A dependency injection framework where the proxy (blob) is the key

## Overview

Diblob is a modern dependency injection framework for TypeScript/JavaScript that uses proxies as both the key and the interface for dependency injection. It provides automatic dependency resolution, reactive updates, and type safety.

## Installation

```bash
pnpm add @speajus/diblob
```

Requirements: Node.js >= 22.0.0. This repository uses **pnpm**, not npm, for
package management.

## Core Concepts

### Blobs

A blob is a proxy object that acts as both a unique identifier and the interface for dependency injection.

```typescript
import { createBlob } from '@speajus/diblob';

const logger = createBlob<Logger>();
const database = createBlob<Database>();
```

### Containers

Containers manage blob registrations and dependency resolution.

```typescript
import { createContainer } from '@speajus/diblob';

const container = createContainer();
container.register(logger, ConsoleLogger);
container.register(database, DatabaseImpl, logger);
```

### List Blobs

List blobs are special blobs for managing arrays with automatic invalidation.

```typescript
import { createListBlob } from '@speajus/diblob';

const todoList = createListBlob<string>();
container.register(todoList, () => []);

// Use as an array
todoList.push('Buy groceries');
todoList.push('Walk the dog');
console.log(todoList.length); // 2
```

**Key Features:**
- Acts exactly like a standard JavaScript array
- All mutation methods (push, pop, shift, unshift, splice, reverse, sort, fill, copyWithin) trigger automatic invalidation
- Creates new array instances on mutation (immutability through re-initialization)
- All read-only methods (map, filter, reduce, find, etc.) work without triggering invalidation
- Can be initialized with empty or pre-populated arrays
- Fully type-safe with TypeScript

**Mutation Example:**
```typescript
const numbers = createListBlob<number>();
container.register(numbers, () => [1, 2, 3]);

numbers.push(4);        // Triggers invalidation
numbers.pop();          // Triggers invalidation
numbers.reverse();      // Triggers invalidation

const doubled = numbers.map(x => x * 2); // No invalidation
```

**With Dependencies:**
```typescript
const todos = createListBlob<string>();
const counter = createBlob<TodoCounter>();

class TodoCounterImpl {
  constructor(private items: string[]) {}
  count() { return this.items.length; }
}

container.register(todos, () => []);
container.register(counter, TodoCounterImpl, todos);

todos.push('Task 1');
console.log(counter.count()); // 1 - automatically updated!
```

## API Reference

### createBlob<T>(name?, metadata?)

Creates a new blob.

```typescript
const logger = createBlob<Logger>('logger');
```

### createListBlob<T>(name?, metadata?)

Creates a list blob for managing arrays.

```typescript
const users = createListBlob<User>('users');
container.register(users, () => []);
users.push({ id: 1, name: 'Alice' });
```

### createContainer(...parents)

Creates a new container, optionally with parent containers.

```typescript
const container = createContainer();
const childContainer = createContainer(container);
```

### container.register(blob, factory, ...deps)

Registers a blob with a factory function and dependencies.

```typescript
container.register(logger, ConsoleLogger);
container.register(database, DatabaseImpl, logger);
container.register(todos, () => ['initial', 'items']);
```

### container.resolve(blobOrConstructor)

Manually resolves a blob or constructor.

```typescript
const loggerInstance = await container.resolve(logger);
```

### container.has(blob)

Checks if a blob is registered.

```typescript
if (container.has(logger)) {
  console.log('Logger is registered');
}
```

### container.unregister(blob)

Unregisters a blob.

```typescript
container.unregister(logger);
```

### container.clear()

Clears all registrations.

```typescript
container.clear();
```

## Features

- **Type Safety**: Full TypeScript support with type inference
- **Reactive Dependencies**: Automatic invalidation and re-resolution when dependencies change
- **Async Support**: Async factories and dependencies
- **Container Nesting**: Hierarchical containers with inheritance
- **Lifecycle Management**: Singleton (default) and Transient lifecycles
- **Constructor Injection**: Automatic dependency injection into class constructors
- **Factory Injection**: Support for factory functions
- **List Blobs**: Special array blobs with automatic invalidation on mutations

## Configuration and Environment Management

### @speajus/diblob-config (typed configuration)

`@speajus/diblob-config` is the canonical way to do typed, validated
configuration in diblob-based applications. It lets you define a schema for
your config, merge values from multiple sources (env, files, CLI), and expose
that config as a blob in your container.

**Installation:**
```bash
pnpm add @speajus/diblob-config
```

**Basic pattern (recommended):**

- Define a TypeScript type `AppConfig`.
- Define a `ConfigSchema<AppConfig>` using Zod (or a compatible schema).
- Create a `createBlob<AppConfig>('appConfig')`.
- Use `registerConfigBlob(container, appConfig, options)` to load and validate
  configuration.

```typescript
import { z } from 'zod';
import { createBlob, createContainer } from '@speajus/diblob';
import {
  type ConfigSchema,
  registerConfigBlob,
} from '@speajus/diblob-config';

type AppConfig = {
  port: number;
  host: string;
};

const AppConfigSchema = z.object({
  port: z.number().int().min(0).max(65535).default(3000),
  host: z.string().default('0.0.0.0'),
}) satisfies ConfigSchema<AppConfig>;

const appConfig = createBlob<AppConfig>('appConfig');
const container = createContainer();

registerConfigBlob(container, appConfig, {
  schema: AppConfigSchema,
  envPrefix: 'APP_',
  env: process.env,
});
```

After this, any blob or class that depends on `appConfig` gets a **fully
validated, typed config object** resolved from env (and other sources you
configure).

#### Node helpers

The `@speajus/diblob-config/node` entrypoint adds helpers for Node CLI
applications:

- `loadNodeConfig<T>(options)` – automatically reads `process.env`,
  `process.argv`, optional JSON files, and deduces the environment name, then
  calls `loadConfig` under the hood.
- `buildConfigHelpText<T>(options)` – generates CLI help text from your schema
  (env/CLI mappings, defaults, descriptions).
- `printNodeConfigHelpIfRequested<T>(options)` – prints help and returns a flag
  so you can exit early when `--help` is requested.

```typescript
import { loadNodeConfig } from '@speajus/diblob-config/node';

const appConfig = await loadNodeConfig<AppConfig>({
  schema: AppConfigSchema,
  envPrefix: 'APP_',
});
```

For tests, you can use `registerStaticConfigBlob(container, blob, value)` to
inject a prebuilt config object without touching the environment.

## LLM-driven diagnostics and debugging helper

The `@speajus/diblob-diagnostics` package provides a reusable diagnostics
helper for blob-centric debugging and incident triage. It records lightweight
`DiagnosticsEvent` objects (blob name, message, severity, outcome,
timestamp, duration, and context), keeps an in-memory ring buffer of recent
events, and exposes a `diagnosticsAggregator` blob that can calculate a
`DiagnosticsSnapshot` over a configurable time window.

A snapshot contains per-blob summaries with:

- Event counts by severity (debug/info/warn/error).
- Success vs failure counts.
- Average and p95 durations (when provided).
- The last error message and timestamp.
- A computed health classification: `healthy`, `degraded`, or `failing`.

This data can be consumed in three main ways:

1. **MCP diagnostics tool** – `@speajus/diblob-mcp` exposes a
   `diagnostics_summarize_recent_activity` tool when diagnostics blobs are
   registered in the container. The tool accepts options like
   `windowSeconds`, `maxBlobs`, and `severityThreshold`, then returns both a
   short, human/LLM-friendly text summary and a JSON snapshot.

2. **DiagnosticsService (Buf + Connect)** – the `example-grpc-server`
   example hosts a `DiagnosticsService` gRPC/Connect endpoint generated from
   `diagnostics.proto`. It takes the same window/max/severity inputs and
   returns a `GetDiagnosticsSnapshotResponse` with summary text and per-blob
   `DiagnosticsBlobSummary` records.

3. **Example diagnostics frontend** – the `example-diagnostics-web` package
   is a Svelte 5 web app that calls `DiagnosticsService` over HTTP using
   Connect-Web. It lets you adjust the window and filters, then renders
   per-blob health, counts, and latency metrics.

By combining `@speajus/diblob-diagnostics`, `@speajus/diblob-logger`, and
`@speajus/diblob-telemetry`, you get a canonical, reusable way to expose
recent operational state to both humans and LLMs.

## Documentation

Full documentation: https://jspears.github.io/diblob/

- Guide: https://jspears.github.io/diblob/diblob/guide/getting-started
- API Reference: https://jspears.github.io/diblob/diblob/api/
- Examples: https://jspears.github.io/diblob/diblob/examples/

## Packages

The diblob ecosystem consists of multiple packages:

### @speajus/diblob

The core dependency injection framework. See above for full documentation.

### @speajus/diblob-config

Typed, validated configuration for diblob applications. Defines schemas for
configuration, merges values from env/files/CLI, and exposes the result as a
config blob in your container. See the "Configuration and Environment
Management" section above for details and examples.

### @speajus/diblob-telemetry

OpenTelemetry-based telemetry integration for diblob containers.

**Installation:**
```bash
pnpm add @speajus/diblob-telemetry @speajus/diblob
```

**Purpose:**
Provides tracing and metrics for applications built with diblob, including
configurable exporters (OTLP, console, or none).

**Configuration:**
- `serviceName`, `serviceVersion`, `deploymentEnvironment`
- `exporter` (e.g. `otlp-http`, `console`, `none`)
- `exporterEndpoint`
- `traceSampleRatio`

Can be configured directly from env vars or via a typed config object loaded
with `@speajus/diblob-config`.

### @speajus/diblob-logger

Winston-based logger integration for diblob containers.

**Installation:**
```bash
pnpm add @speajus/diblob-logger @speajus/diblob
```

**Purpose:**
Provides a blob-based logger using Winston, with configuration driven through
config blobs (and typically `@speajus/diblob-config`). Plays well with
`@speajus/diblob-telemetry` for correlated logs and traces.

### @speajus/diblob-connect

Connect-based gRPC server implementation for diblob containers.

**Installation:**
```bash
pnpm add @speajus/diblob-connect @speajus/diblob @connectrpc/connect @connectrpc/connect-node @bufbuild/protobuf
```

**Purpose:**
Provides a Connect/ES-powered gRPC/Connect/gRPC-Web server whose lifecycle and
configuration are managed through a diblob container.

**Key concepts:**
- `registerGrpcBlobs(container, config)` to register server blobs
- `grpcServer` blob to start the server on first resolve
- `grpcServiceRegistry` for registering service implementations

### @speajus/diblob-svelte

Svelte 5 integration helpers for diblob containers.

**Installation:**
```bash
pnpm add @speajus/diblob-svelte @speajus/diblob svelte
```

**Purpose:**
Makes it easy to provide a diblob container via Svelte context and resolve
blobs from components.

**Key helpers:**
- `provideContainerContext(container)` – store a container in Svelte context
- `useContainer()` – retrieve the current container
- `useBlob(blob)` – resolve a blob from the current container
- `attachContainerDisposal(container)` – dispose container when the owning
  component is destroyed

### @speajus/diblob-testing

Testing utilities and fake infrastructure blobs for diblob containers.

**Installation:**
```bash
pnpm add -D @speajus/diblob-testing
```

**Purpose:**
Provides test container factories, blob override helpers, and fake
infrastructure (logger, clock, random, HTTP stubs), plus helpers for
`node:test`.

**Key features:**
- `createTestContainer` / `createIsolatedTestContainer`
- `withBlobOverride(container, blob, impl, testFn)`
- `testLogger`, `testClock`, `testRandom`, `httpClientStub`, `httpServerStub`
- `setupFileScopedTestContainer` and `setupEachTestContainer`

### @speajus/diblob-mcp

Model Context Protocol (MCP) server implementation for diblob containers.

**Installation:**
```bash
pnpm add @speajus/diblob-mcp @speajus/diblob @modelcontextprotocol/sdk
```

**Purpose:**
Exposes diblob container functionality through the Model Context Protocol, enabling AI assistants and other MCP clients to introspect and interact with dependency injection containers.

**Features:**
- MCP server with stdio transport
- Container introspection tools
- Dependency graph visualization
- List and inspect registered blobs
- Query blob details and dependencies

**Quick Start:**
```typescript
import { createContainer } from '@speajus/diblob';
import { registerMcpBlobs, mcpServer } from '@speajus/diblob-mcp';

// Create a diblob container
const container = createContainer();

// Register your application blobs
// ... your blob registrations ...

// Register MCP server blobs
registerMcpBlobs(container);

// Start the MCP server
await mcpServer.start();
```

**Architecture:**
Following diblob conventions, the package separates:
- **Interface/Blob Definitions** (`blobs.ts`): Type definitions and blob declarations
- **Implementations** (`server.ts`): Concrete MCP server and introspector implementations
- **Registration** (`register.ts`): `registerMcpBlobs(container)` function for grouping related registrations

**Available MCP Tools:**
- `list_blobs`: List all registered blobs in the container
- `get_blob_details`: Get detailed information about a specific blob (dependencies, lifecycle, metadata)
- `get_dependency_graph`: Get the complete dependency graph as nodes and edges

**Custom Configuration:**
```typescript
registerMcpBlobs(container, {
  name: 'my-custom-mcp-server',
  version: '1.0.0',
  description: 'Custom MCP server for my application'
});
```

**API Reference:**
- `registerMcpBlobs(container, config?)`: Register all MCP blobs with a container
- `mcpServer`: Blob for the MCP server instance
- `mcpServerConfig`: Blob for server configuration
- `mcpTransport`: Blob for the transport layer
- `containerIntrospector`: Blob for container introspection service

### @speajus/diblob-visualizer

Interactive dependency injection graph visualization for diblob.

**Installation:**
```bash
pnpm add @speajus/diblob-visualizer @speajus/diblob
```

**Purpose:**
Provides a Svelte-based visualization tool for exploring diblob container dependency graphs with real-time updates and interactive features.

**Features:**
- Real-time graph visualization
- Interactive node manipulation (drag, pan, zoom)
- Lifecycle indicators (Singleton/Transient)
- Statistics dashboard
- Metadata display

## License

MIT

