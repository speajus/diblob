# Diblob - Dependency Injection Framework

> A dependency injection framework where the proxy (blob) is the key

## Overview

Diblob is a modern dependency injection framework for TypeScript/JavaScript that uses proxies as both the key and the interface for dependency injection. It provides automatic dependency resolution, reactive updates, and type safety.

## Installation

```bash
npm install @speajus/diblob
```

Requirements: Node.js >= 22.0.0

## Core Concepts

### Blobs

A blob is a proxy object that acts as both a unique identifier and the interface for dependency injection.

```typescript
import { createBlob } from '@speajus/diblob';

const logger = createBlob<Logger>();
const database = createBlob<Database>();
```

### Containers

Containers manage blob registrations and dependency resolution.

```typescript
import { createContainer } from '@speajus/diblob';

const container = createContainer();
container.register(logger, ConsoleLogger);
container.register(database, DatabaseImpl, logger);
```

### List Blobs

List blobs are special blobs for managing arrays with automatic invalidation.

```typescript
import { createListBlob } from '@speajus/diblob';

const todoList = createListBlob<string>();
container.register(todoList, () => []);

// Use as an array
todoList.push('Buy groceries');
todoList.push('Walk the dog');
console.log(todoList.length); // 2
```

**Key Features:**
- Acts exactly like a standard JavaScript array
- All mutation methods (push, pop, shift, unshift, splice, reverse, sort, fill, copyWithin) trigger automatic invalidation
- Creates new array instances on mutation (immutability through re-initialization)
- All read-only methods (map, filter, reduce, find, etc.) work without triggering invalidation
- Can be initialized with empty or pre-populated arrays
- Fully type-safe with TypeScript

**Mutation Example:**
```typescript
const numbers = createListBlob<number>();
container.register(numbers, () => [1, 2, 3]);

numbers.push(4);        // Triggers invalidation
numbers.pop();          // Triggers invalidation
numbers.reverse();      // Triggers invalidation

const doubled = numbers.map(x => x * 2); // No invalidation
```

**With Dependencies:**
```typescript
const todos = createListBlob<string>();
const counter = createBlob<TodoCounter>();

class TodoCounterImpl {
  constructor(private items: string[]) {}
  count() { return this.items.length; }
}

container.register(todos, () => []);
container.register(counter, TodoCounterImpl, todos);

todos.push('Task 1');
console.log(counter.count()); // 1 - automatically updated!
```

## API Reference

### createBlob<T>(name?, metadata?)

Creates a new blob.

```typescript
const logger = createBlob<Logger>('logger');
```

### createListBlob<T>(name?, metadata?)

Creates a list blob for managing arrays.

```typescript
const users = createListBlob<User>('users');
container.register(users, () => []);
users.push({ id: 1, name: 'Alice' });
```

### createContainer(...parents)

Creates a new container, optionally with parent containers.

```typescript
const container = createContainer();
const childContainer = createContainer(container);
```

### container.register(blob, factory, ...deps)

Registers a blob with a factory function and dependencies.

```typescript
container.register(logger, ConsoleLogger);
container.register(database, DatabaseImpl, logger);
container.register(todos, () => ['initial', 'items']);
```

### container.resolve(blobOrConstructor)

Manually resolves a blob or constructor.

```typescript
const loggerInstance = await container.resolve(logger);
```

### container.has(blob)

Checks if a blob is registered.

```typescript
if (container.has(logger)) {
  console.log('Logger is registered');
}
```

### container.unregister(blob)

Unregisters a blob.

```typescript
container.unregister(logger);
```

### container.clear()

Clears all registrations.

```typescript
container.clear();
```

## Features

- **Type Safety**: Full TypeScript support with type inference
- **Reactive Dependencies**: Automatic invalidation and re-resolution when dependencies change
- **Async Support**: Async factories and dependencies
- **Container Nesting**: Hierarchical containers with inheritance
- **Lifecycle Management**: Singleton (default) and Transient lifecycles
- **Constructor Injection**: Automatic dependency injection into class constructors
- **Factory Injection**: Support for factory functions
- **List Blobs**: Special array blobs with automatic invalidation on mutations

## Documentation

Full documentation: https://jspears.github.io/diblob/

- Guide: https://jspears.github.io/diblob/diblob/guide/getting-started
- API Reference: https://jspears.github.io/diblob/diblob/api/
- Examples: https://jspears.github.io/diblob/diblob/examples/

## Packages

The diblob ecosystem consists of multiple packages:

### @speajus/diblob

The core dependency injection framework. See above for full documentation.

### @speajus/diblob-mcp

Model Context Protocol (MCP) server implementation for diblob containers.

**Installation:**
```bash
npm install @speajus/diblob-mcp @speajus/diblob @modelcontextprotocol/sdk
```

**Purpose:**
Exposes diblob container functionality through the Model Context Protocol, enabling AI assistants and other MCP clients to introspect and interact with dependency injection containers.

**Features:**
- MCP server with stdio transport
- Container introspection tools
- Dependency graph visualization
- List and inspect registered blobs
- Query blob details and dependencies

**Quick Start:**
```typescript
import { createContainer } from '@speajus/diblob';
import { registerMcpBlobs, mcpServer } from '@speajus/diblob-mcp';

// Create a diblob container
const container = createContainer();

// Register your application blobs
// ... your blob registrations ...

// Register MCP server blobs
registerMcpBlobs(container);

// Start the MCP server
await mcpServer.start();
```

**Architecture:**
Following diblob conventions, the package separates:
- **Interface/Blob Definitions** (`blobs.ts`): Type definitions and blob declarations
- **Implementations** (`server.ts`): Concrete MCP server and introspector implementations
- **Registration** (`register.ts`): `registerMcpBlobs(container)` function for grouping related registrations

**Available MCP Tools:**
- `list_blobs`: List all registered blobs in the container
- `get_blob_details`: Get detailed information about a specific blob (dependencies, lifecycle, metadata)
- `get_dependency_graph`: Get the complete dependency graph as nodes and edges

**Custom Configuration:**
```typescript
registerMcpBlobs(container, {
  name: 'my-custom-mcp-server',
  version: '1.0.0',
  description: 'Custom MCP server for my application'
});
```

**API Reference:**
- `registerMcpBlobs(container, config?)`: Register all MCP blobs with a container
- `mcpServer`: Blob for the MCP server instance
- `mcpServerConfig`: Blob for server configuration
- `mcpTransport`: Blob for the transport layer
- `containerIntrospector`: Blob for container introspection service

### @speajus/diblob-visualizer

Interactive dependency injection graph visualization for diblob.

**Installation:**
```bash
npm install @speajus/diblob-visualizer @speajus/diblob
```

**Purpose:**
Provides a Svelte-based visualization tool for exploring diblob container dependency graphs with real-time updates and interactive features.

**Features:**
- Real-time graph visualization
- Interactive node manipulation (drag, pan, zoom)
- Lifecycle indicators (Singleton/Transient)
- Statistics dashboard
- Metadata display

## License

MIT

